/* -------------------------------------------------------------------------- *
 *                                   OpenMM                                   *
 * -------------------------------------------------------------------------- *
 * This is part of the OpenMM molecular simulation toolkit originating from   *
 * Simbios, the NIH National Center for Physics-Based Simulation of           *
 * Biological Structures at Stanford, funded under the NIH Roadmap for        *
 * Medical Research, grant U54 GM072970. See https://simtk.org.               *
 *                                                                            *
 * Portions copyright (c) 2012 Stanford University and the Authors.           *
 * Authors: Peter Eastman                                                     *
 * Contributors:                                                              *
 *                                                                            *
 * This program is free software: you can redistribute it and/or modify       *
 * it under the terms of the GNU Lesser General Public License as published   *
 * by the Free Software Foundation, either version 3 of the License, or       *
 * (at your option) any later version.                                        *
 *                                                                            *
 * This program is distributed in the hope that it will be useful,            *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of             *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              *
 * GNU Lesser General Public License for more details.                        *
 *                                                                            *
 * You should have received a copy of the GNU Lesser General Public License   *
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.      *
 * -------------------------------------------------------------------------- */

#include "CudaLTMDKernelSources.h"

using namespace OpenMM;
using namespace std;


const string CudaLTMDKernelSources::NMLupdates = "typedef mixed Real;\n"
"\n"
"extern \"C\" __global__ void kNMLUpdate1_kernel( int numAtoms, int paddedNumAtoms, mixed tau, mixed dt, mixed kT, mixed4* velm, long long* force,\n"
"					real4 *random, /*int randomPosition,*/ int* randomPosition, int totalRandoms ) {\n"
"	// Update the velocity.\n"
"	const Real vscale = exp( -dt / tau );\n"
"	const Real fscale = ( 1.0f - vscale ) * tau;\n"
"	const Real noisescale = sqrt( kT * ( 1 - vscale * vscale ) );\n"
"\n"
"	int rpos = randomPosition[blockIdx.x];\n"
"	//int rpos = randomPosition;\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		//const real4 n = make_real4(0,0,0,0);\n"
"		const real4 n = random[rpos + atom];\n"
"		const mixed4 randomNoise = make_mixed4( n.x * noisescale, n.y * noisescale, n.z * noisescale, n.w * noisescale );\n"
"\n"
"		const Real sqrtInvMass = sqrt( velm[atom].w );\n"
"\n"
"		mixed4 v = velm[atom];\n"
"		mixed fx = (mixed)force[atom] / (mixed)0x100000000;\n"
"		mixed fy = (mixed)force[atom+1*paddedNumAtoms] / (mixed)0x100000000;\n"
"		mixed fz = (mixed)force[atom+2*paddedNumAtoms] / (mixed)0x100000000;\n"
"\n"
"		v.x = ( vscale * v.x ) + ( fscale * fx * v.w ) + ( randomNoise.x * sqrtInvMass );\n"
"		v.y = ( vscale * v.y ) + ( fscale * fy * v.w ) + ( randomNoise.y * sqrtInvMass );\n"
"		v.z = ( vscale * v.z ) + ( fscale * fz * v.w ) + ( randomNoise.z * sqrtInvMass );\n"
"\n"
"		velm[atom] = v;\n"
"	}\n"
"\n"
"	if( threadIdx.x == 0 ) {\n"
"		rpos += paddedNumAtoms;\n"
"		if( rpos > totalRandoms ) {\n"
"			rpos -= totalRandoms;\n"
"		}\n"
"		randomPosition[blockIdx.x] = rpos;\n"
"		//randomPosition = rpos;\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kNMLUpdate2_kernel( int numAtoms, int numModes, mixed4 *velm, mixed4 *modes, mixed *modeWeights ) {\n"
"	extern __shared__ mixed dotBuffer[];\n"
"	for( int mode = blockIdx.x; mode < numModes; mode += gridDim.x ) {\n"
"		// Compute the projection of the mass weighted velocity onto one normal mode vector.\n"
"		Real dot = 0.0f;\n"
"\n"
"		for( int atom = threadIdx.x; atom < numAtoms; atom += blockDim.x ) {\n"
"			const int modePos = mode * numAtoms + atom;\n"
"			const Real scale = 1.0f / sqrt( velm[atom].w );\n"
"\n"
"			mixed4 v = velm[atom];\n"
"			mixed4 m = modes[modePos];\n"
"\n"
"			dot += scale * ( v.x * m.x + v.y * m.y + v.z * m.z );\n"
"		}\n"
"\n"
"		dotBuffer[threadIdx.x] = dot;\n"
"\n"
"		__syncthreads();\n"
"		if( threadIdx.x == 0 ) {\n"
"			Real sum = 0;\n"
"			for( int i = 0; i < blockDim.x; i++ ) {\n"
"				sum += dotBuffer[i];\n"
"			}\n"
"			modeWeights[mode] = sum;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kNMLUpdate3_kernel( int numAtoms, int numModes, mixed dt, real4 *posq, real4 *posqCorrection, mixed4 *velm, mixed4 *modes,\n"
"					 mixed *modeWeights, mixed4 *noiseVal ) {\n"
"	// Load the weights into shared memory.\n"
"	extern __shared__ mixed weightBuffer[];\n"
"	for( int mode = threadIdx.x; mode < numModes; mode += blockDim.x ) {\n"
"		weightBuffer[mode] = modeWeights[mode];\n"
"	}\n"
"	__syncthreads();\n"
"\n"
"	// Compute the projected velocities and update the atom positions.\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real invMass = velm[atom].w, scale = sqrt( invMass );\n"
"\n"
"		mixed3 v = make_mixed3( 0.0f, 0.0f, 0.0f );\n"
"		for( int mode = 0; mode < numModes; mode++ ) {\n"
"			mixed4 m = modes[mode * numAtoms + atom];\n"
"			mixed weight = weightBuffer[mode];\n"
"			v.x += m.x * weight;\n"
"			v.y += m.y * weight;\n"
"			v.z += m.z * weight;\n"
"		}\n"
"\n"
"		v.x *= scale;\n"
"		v.y *= scale;\n"
"		v.z *= scale;\n"
"		velm[atom] = make_mixed4( v.x, v.y, v.z, invMass );\n"
"\n"
"#ifdef USE_MIXED_PRECISON\n"
"		real4 pos1 = posq[atom];\n"
"		real4 pos2 = posqCorrection[atom];\n"
"		mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"		real4 pos = posq[atom];\n"
"#endif\n"
"\n"
"		// Add Step\n"
"		pos.x += dt * v.x;\n"
"		pos.y += dt * v.y;\n"
"		pos.z += dt * v.z;\n"
"\n"
"#ifdef FAST_NOISE\n"
"		// Remove Noise\n"
"		pos.x -= noiseVal[atom].x;\n"
"		pos.y -= noiseVal[atom].y;\n"
"		pos.z -= noiseVal[atom].z;\n"
"#endif\n"
"\n"
"#ifdef USE_MIXED_PRECISON\n"
"		posq[atom] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"		posqCorrection[atom] = make_real4(pos.x-(real)pos.x, pos.y-(real)pos.y, pos.z-(real)pos.z, 0);\n"
"#else\n"
"		posq[atom] = pos;\n"
"#endif\n"
"	}\n"
"}\n"
"";

const string CudaLTMDKernelSources::fastnoises = "typedef mixed Real;\n"
"\n"
"#ifdef FAST_NOISE\n"
"extern \"C\" __global__ void kFastNoise1_kernel( int numAtoms, int paddedNumAtoms, int numModes, mixed kT, real4 *noiseVal, mixed4 *velm, mixed4 *modes,\n"
" 					mixed *modeWeights, real4 *random, int *randomPosition, int totalRandoms, mixed maxEigenvalue, mixed stepSize ) {\n"
"	extern __shared__ real dotBuffer[];\n"
"	const Real val = stepSize / 0.002;\n"
"	const Real noisescale = sqrt( 2 * kT * 1.0f / maxEigenvalue );\n"
"\n"
"	int rpos = randomPosition[blockIdx.x];\n"
"	for( int mode = blockIdx.x; mode < numModes; mode += gridDim.x ) {\n"
"		Real dot = 0.0f;\n"
"               unsigned int seed=100;\n"
"\n"
"		for( int atom = threadIdx.x; atom < numAtoms; atom += blockDim.x ) {\n"
"			const real4 n = random[rpos + atom];\n"
"                       /*real v1,v2,s;\n"
"                       real arr[4];\n"
"                       int i;\n"
"                       for (i = 0; i < 4; i++) {\n"
"                       do {\n" 
"                          unsigned long a = 16807;\n"
"                          unsigned long m = 2147483647;\n"
"                          unsigned long x = seed;\n"
"                          x = (a*x)%m;\n"
"                          seed = (unsigned int)x;\n"
"                          real rand= ((real)x/m);\n"
"                          v1 = 2.0 * ((real) rand/RAND_MAX) - 1;\n"
"                          v2 = 2.0 * ((real) rand/RAND_MAX) - 1;\n"
"                          s = v1*v1 + v2*v2;\n"
"                       } while ( s >= 1.0 );\n"
"                       if (s == 0.0)\n"
"                           arr[i]=0.0;\n"
"                       else\n"
"			    arr[i]= (v1*sqrt(-2.0 * log(s) / s));\n"
"                       }*/\n"
"			const real4 randomNoise = make_real4( n.x * noisescale, n.y * noisescale, n.z * noisescale, n.w * noisescale );\n"
"\n"
"			noiseVal[atom] = randomNoise;\n"
"\n"
"			mixed4 m = modes[mode * numAtoms + atom];\n"
"			dot += randomNoise.x * m.x + randomNoise.y * m.y + randomNoise.z * m.z;\n"
"		}\n"
"\n"
"		dotBuffer[threadIdx.x] = dot;\n"
"\n"
"		__syncthreads();\n"
"		if( threadIdx.x == 0 ) {\n"
"			Real sum = 0;\n"
"			for( int i = 0; i < blockDim.x; i++ ) {\n"
"				sum += dotBuffer[i];\n"
"			}\n"
"			modeWeights[mode] = sum;\n"
"\n"
"			rpos += paddedNumAtoms;\n"
"			if( rpos > totalRandoms ) {\n"
"				rpos -= totalRandoms;\n"
"			}\n"
"			randomPosition[blockIdx.x] = rpos;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kFastNoise2_kernel( int numAtoms, int numModes, real4 *posq, real4 *posqCorrection, mixed4 *noiseVal, mixed4 *velm, mixed4 *modes, mixed *modeWeights ) {\n"
"	// Load the weights into shared memory.\n"
"	extern __shared__ mixed weightBuffer[];\n"
"	for( int mode = threadIdx.x; mode < numModes; mode += blockDim.x ) {\n"
"		weightBuffer[mode] = modeWeights[mode];\n"
"	}\n"
"	__syncthreads();\n"
"\n"
"	// Compute the projected forces and update the atom positions.\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real invMass = velm[atom].w, sqrtInvMass = sqrt( invMass );\n"
"\n"
"		mixed3 r = make_mixed3( 0.0f, 0.0f, 0.0f );\n"
"		for( int mode = 0; mode < numModes; mode++ ) {\n"
"			mixed4 m = modes[mode * numAtoms + atom];\n"
"			mixed weight = weightBuffer[mode];\n"
"			r.x += m.x * weight;\n"
"			r.y += m.y * weight;\n"
"			r.z += m.z * weight;\n"
"		}\n"
"\n"
"		noiseVal[atom] = make_mixed4( noiseVal[atom].x - r.x, noiseVal[atom].y - r.y, noiseVal[atom].z - r.z, 0.0f );\n"
"		noiseVal[atom].x *= sqrtInvMass;\n"
"		noiseVal[atom].y *= sqrtInvMass;\n"
"		noiseVal[atom].z *= sqrtInvMass;\n"
"\n"
"#ifdef USE_MIXED_PRECISON\n"
"		real4 pos1 = posq[atom];\n"
"		real4 pos2 = posqCorrection[atom];\n"
"		mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"		real4 pos = posq[atom];\n"
"#endif\n"
"		pos.x += noiseVal[atom].x;\n"
"		pos.y += noiseVal[atom].y;\n"
"		pos.z += noiseVal[atom].z;\n"
"#ifdef USE_MIXED_PRECISON\n"
"		posq[atom] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"		posqCorrection[atom] = make_real4(pos.x-(real)pos.x, pos.y-(real)pos.y, pos.z-(real)pos.z, 0);\n"
"#else\n"
"		posq[atom] = pos;\n"
"#endif\n"
"	}\n"
"}\n"
"#endif\n"
"";

const string CudaLTMDKernelSources::minimizationSteps = "\n"
"extern \"C\" __global__ void kRejectMinimizationStep_kernel( int numAtoms, real4 *posq, real4* posqCorrection, real4 *oldPosq, real4* oldPosqCorrection ) {\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		posq[atom] = oldPosq[atom];\n"
"		posqCorrection[atom] = oldPosqCorrection[atom];\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kAcceptMinimizationStep_kernel( int numAtoms, real4 *posq, real4* posqCorrection, real4 *oldPosq, real4* oldPosqCorrection ) {\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		oldPosq[atom] = posq[atom];\n"
"		oldPosqCorrection[atom] = posqCorrection[atom];\n"
"	}\n"
"}\n"
"";

const string CudaLTMDKernelSources::linearMinimizers = "typedef mixed Real;\n"
"\n"
"extern \"C\" __global__ void kNMLLinearMinimize1_kernel( int numAtoms, int paddedNumAtoms, int numModes, mixed4 *velm, long long *force, mixed4 *modes, mixed *modeWeights ) {\n"
"	extern __shared__ mixed dotBuffer[];\n"
"	for( int mode = blockIdx.x; mode < numModes; mode += gridDim.x ) {\n"
"		// Compute the projection of the mass weighted force onto one normal mode vector.\n"
"		Real dot = 0.0f;\n"
"		for( int atom = threadIdx.x; atom < numAtoms; atom += blockDim.x ) {\n"
"			const Real scale = sqrt( velm[atom].w );\n"
"			const int modePos = mode * numAtoms + atom;\n"
"\n"
"			mixed fx = (mixed)force[atom] / (mixed)0x100000000;\n"
"			mixed fy = (mixed)force[atom+1*paddedNumAtoms] / (mixed)0x100000000;\n"
"			mixed fz = (mixed)force[atom+2*paddedNumAtoms] / (mixed)0x100000000;\n"
"			mixed4 m = modes[modePos];\n"
"\n"
"			dot += scale * ( fx * m.x + fy * m.y + fz * m.z );\n"
"		}\n"
"		dotBuffer[threadIdx.x] = dot;\n"
"\n"
"		__syncthreads();\n"
"		if( threadIdx.x == 0 ) {\n"
"			Real sum = 0;\n"
"			for( int i = 0; i < blockDim.x; i++ ) {\n"
"				sum += dotBuffer[i];\n"
"			}\n"
"			modeWeights[mode] = sum;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kNMLLinearMinimize2_kernel( int numAtoms, int paddedNumAtoms, int numModes, mixed invMaxEigen, real4 *posq, real4 *posqCorrection, real4 *posqP, real4 *posqPCorrection, mixed4 *velm,\n"
"						 long long *force, mixed4 *modes, mixed *modeWeights ) {\n"
"	// Load the weights into shared memory.\n"
"	extern __shared__ mixed weightBuffer[];\n"
"	for( int mode = threadIdx.x; mode < numModes; mode += blockDim.x ) {\n"
"		weightBuffer[mode] = modeWeights[mode];\n"
"	}\n"
"	__syncthreads();\n"
"\n"
"	// Compute the projected forces and update the atom positions.\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real invMass = velm[atom].w, sqrtInvMass = sqrt( invMass ), factor = invMass * invMaxEigen;\n"
"\n"
"		mixed3 f = make_mixed3( 0.0f, 0.0f, 0.0f );\n"
"		for( int mode = 0; mode < numModes; mode++ ) {\n"
"			mixed4 m = modes[mode * numAtoms + atom];\n"
"			mixed weight = weightBuffer[mode];\n"
"			f.x += m.x * weight;\n"
"			f.y += m.y * weight;\n"
"			f.z += m.z * weight;\n"
"		}\n"
"\n"
"		f.x *= sqrtInvMass;\n"
"		f.y *= sqrtInvMass;\n"
"		f.z *= sqrtInvMass;\n"
"#ifdef USED_MIXED_PRECISION\n"
"		real4 pos1 = posq[atom];\n"
"		real4 pos2 = posqCorrection[atom];\n"
"		mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"		mixed4 posqTemp = make_mixed4( (mixed)force[atom] / (mixed)0x100000000 - f.x, (mixed)force[atom+paddedNumAtoms]/(mixed) 0x100000000 - f.y, (mixed) force[atom+2*paddedNumAtoms]/(mixed) 0x100000000  - f.z, 0.0f );\n"
"		posqP[atom] = make_real4( (real)force[atom] / (real)0x100000000 - f.x, (real)force[atom+paddedNumAtoms]/(real) 0x100000000 - f.y, (real) force[atom+2*paddedNumAtoms]/(real) 0x100000000  - f.z, 0.0f );\n"
"		posqPCorrection[atom] = posqTemp - posqP[atom]\n"
"		pos.x += factor * posqTemp.x\n"
"		pos.y += factor * posqTemp.y\n"
"		pos.z += factor * posqTemp.z\n"
"		posq[atom] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"		posqCorrection[atom] = make_real4(pos.x-(real)pos.x, pos.y-(real)pos.y, pos.z-(real)pos.z, 0);\n"
"#else\n"
"		posqP[atom] = make_real4( (real)force[atom] / (real)0x100000000 - f.x, (real)force[atom+paddedNumAtoms]/(real) 0x100000000 - f.y, (real) force[atom+2*paddedNumAtoms]/(real) 0x100000000  - f.z, 0.0f );\n"
"\n"
"		real4 pos = posq[atom];\n"
"		pos.x += factor * posqP[atom].x;\n"
"		pos.y += factor * posqP[atom].y;\n"
"		pos.z += factor * posqP[atom].z;\n"
"		posq[atom] = pos;\n"
"#endif\n"
"	}\n"
"}\n"
"";


const string CudaLTMDKernelSources::quadraticMinimizers = "typedef mixed Real;\n"
"\n"
"extern \"C\" __global__ void kNMLQuadraticMinimize1_kernel( int numAtoms, int paddedNumAtoms, real4 *posqP, real4 *posqPCorrection, mixed4 *velm, long long *force, mixed *blockSlope ) {\n"
"	// Compute the slope along the minimization direction.\n"
"	extern __shared__ mixed slopeBuffer[];\n"
"\n"
"	Real slope = 0.0f;\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real invMass = velm[atom].w;\n"
"#ifdef USE_MIXED_PRECISION\n"
"		real4 pos1 = posqP[atom];\n"
"		real4 pos2 = posqPCorrection[atom];\n"
"		const mixed4 xp = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"#else\n"
"		const real4 xp = posqP[atom];\n"
"#endif\n"
"			const mixed fx = (mixed)force[atom] / (mixed)0x100000000;\n"
"			const mixed fy = (mixed)force[atom+1*paddedNumAtoms] / (mixed)0x100000000;\n"
"			const mixed fz = (mixed)force[atom+2*paddedNumAtoms] / (mixed)0x100000000;\n"
"\n"
"		slope -= invMass * ( xp.x * fx + xp.y * fy + xp.z * fz );\n"
"	}\n"
"	slopeBuffer[threadIdx.x] = slope;\n"
"	__syncthreads();\n"
"	if( threadIdx.x == 0 ) {\n"
"		for( int i = 1; i <  blockDim.x; i++ ) {\n"
"			slope += slopeBuffer[i];\n"
"		}\n"
"		blockSlope[blockIdx.x] = slope;\n"
"	}\n"
"}\n"
"\n"
"extern \"C\" __global__ void kNMLQuadraticMinimize2_kernel( int numAtoms, mixed currentPE, mixed lastPE, mixed invMaxEigen, real4 *posq, real4 *posqCorrection, real4 *posqP, real4 *posqPCorrection, \n" 
"						mixed4 *velm, mixed *blockSlope, mixed *lambdaval ) {\n"
"	// Load the block contributions into shared memory.\n"
"	extern __shared__ mixed slopeBuffer[];\n"
"	for( int block = threadIdx.x; block < gridDim.x; block += blockDim.x ) {\n"
"		slopeBuffer[block] = blockSlope[block];\n"
"	}\n"
"\n"
"	__syncthreads();\n"
"\n"
"	// Compute the scaling coefficient.\n"
"	if( threadIdx.x == 0 ) {\n"
"		Real slope = 0.0f;\n"
"		for( int i = 0; i < gridDim.x; i++ ) {\n"
"			slope += slopeBuffer[i];\n"
"		}\n"
"		Real lambda = invMaxEigen;\n"
"		Real oldLambda = lambda;\n"
"		Real a = ( ( ( lastPE - currentPE ) / oldLambda + slope ) / oldLambda );\n"
"\n"
"		if( a != 0.0f ) {\n"
"			const Real b = slope - 2.0f * a * oldLambda;\n"
"			lambda = -b / ( 2.0f * a );\n"
"		} else {\n"
"			lambda = 0.5f * oldLambda;\n"
"		}\n"
"\n"
"		if( lambda <= 0.0f ) {\n"
"			lambda = 0.5f * oldLambda;\n"
"		}\n"
"\n"
"		slopeBuffer[0] = lambda - oldLambda;\n"
"\n"
"		// Store variables for retrival\n"
"		lambdaval[0] = lambda;\n"
"	}\n"
"\n"
"	__syncthreads();\n"
"\n"
"	// Remove previous position update (-oldLambda) and add new move (lambda).\n"
"	const Real dlambda = slopeBuffer[0];\n"
"	for( int atom = threadIdx.x + blockIdx.x * blockDim.x; atom < numAtoms; atom += blockDim.x * gridDim.x ) {\n"
"		const Real factor = velm[atom].w * dlambda;\n"
"\n"
"#ifdef USE_MIXED_PRECISION\n"
"		real4 pos1 = posq[atom];\n"
"		real4 pos2 = posqCorrection[atom];\n"
"		mixed4 pos = make_mixed4(pos1.x+(mixed)pos2.x, pos1.y+(mixed)pos2.y, pos1.z+(mixed)pos2.z, pos1.w);\n"
"		real4 posP1 = posqP[atom];\n"
"		real4 posP2 = posqPCorrection[atom];\n"
"		mixed4 posP = make_mixed4(posP1.x+(mixed)posP2.x, posP1.y+(mixed)posP2.y, posP1.z+(mixed)posP2.z, posP1.w);\n"
"		pos.x += factor * posP.x;\n"
"		pos.y += factor * posP.y;\n"
"		pos.z += factor * posP.z;\n"
"		posq[atom] = make_real4((real) pos.x, (real) pos.y, (real) pos.z, (real) pos.w);\n"
"		posqCorrection[atom] = make_real4(pos.x-(real)pos.x, pos.y-(real)pos.y, pos.z-(real)pos.z, 0);\n"
"#else\n"
"		real4 pos = posq[atom];\n"
"		pos.x += factor * posqP[atom].x;\n"
"		pos.y += factor * posqP[atom].y;\n"
"		pos.z += factor * posqP[atom].z;\n"
"		posq[atom] = pos;\n"
"#endif\n"
"	}\n"
"}\n"
"";

